# Принципы архитектуры

Да, это тот самый SOLID, и более глубокие, связанные с ними принципы построения архитектуры

Эти базовые принципы применимы к любой парадигме программирования и любому виду ПО, т.к. по своей сути, они описывают правила поведения для логически завершенных объединений значений и функций, которые в ООП, например, являются классами

SRP - Single Responsibility Principle

Принцип единственной ответственности

OCP - Open-Close Principle

LSP - Liskov Substitution Principle

ISP - Interface Segregation Principle

DIP - Dependecy Inversion Principle

# Принципы связности

REP - Reuse/Release Equivivalence Pronciple

Принцип эквивалентности повторного использования и выпусков

Классы и модули, составляющие один общий логический компонент, должны принадлежать одной связанной группе. Обязательно должная быть общая тема/цель/функционал, объединяющие все элементы компонента

Аналогично для релизов компонента - все его составляющие должны входить в этот релиз. Т.е. нельзя выпустить библиотеку для стриминга аудио без поддержки сетевой части этого стриминга

Является включительным, т.к. говорит о  правиле объединении множества объектов в компонент

CCP - Common Closure Principle

Принцип согласованного изменения 

Пересекается с Single Responsibility Principle в рамках одного компонента. Для изменения компонента должна быть всегда одна и только одна конкретная причина. Схож с REP и детальнее раскрывает связность - в рамках компонента должны объединяться классы, которые могут быть изменены по одной общей причине в одно время. В результате мы получаем лучшее деление на компоненты и меньшие трудозатраты по изменению/расширению функционала

Является включительным, т.к. говорит о  правиле объединении множества объектов в компонент

CRP - Common Reuse Principle

Принцип совместного повторного использования

Определяет правило включения классов/модулей в один общий компонент по принципу - компонент может зависеть только от тех объектов, функционал которых он использует, не должно быть лишних зависимостей, в лучшем случае компонент должен зависеть только от объектов, функции которых используются полностью (или хотя бы относятся по своему смыслу исключительно к задачам компонента). 

Нарушение принципа ведет к появлению лишних не используемых зависимостей (функций) в компоненте ведет к ситуации когда изменения в подключенной к компоненту зависимости ведут за собой изменения в самом компоненте, что необходимо исключать в правильной архитектуре

Является обобщенной версией принципа ISP, т.к. так же является исключительным, и стремиться к уменьшению компонентов 

В итоге получается противоречие между принципами REP/CCP и CRP. Первые два включительные и стремятся к увеличению компонента через объединение его частей по правилам, а второй наоборот говорит об исключении лишних зависимостей. Отсюда получается, что одна из главных задач архитектора - поиск баланса между этими принципами, исходя из условий задачи

**Важно помнить:**

- **В начале разработки баланс обычно смещен в пользу CCP и дешевле пожертвовать повторным использование в угоду скорости и удобства разработки, по мере развития проекта уклон будет уже в пользу CRP т.к. все больше компонентов будут переиспользоваться и его необходимо соблюдать для большей гибкости в поддержке и расширении**
- **Баланс между соблюдением тех или иных принципов постоянно смещается, это нормально и за этим необходимо следить, т.к. удачное разбиение компонентов на первом этапе развития приложения, может быть неактуальным в дальнейшем и компоненты будут постоянно меняться с течением времени**

# Принципы сочетаемости компонентов

И снова важен баланс - принципы проектирования могут противоречить или ограничивать друг друга и то, в какую сторону какого принципа вести дизайн больше - зависит от задач, контекста и планов развития проекта

### ADP - Acyclic Dependecies Princilple Принцип ацикличности зависимостей

Принцип ацикличности зависимостей - недопустимы циклы в графе зависимостей, самый простой пример - ошибка с циклической зависимостью при сборке графа Dagger 2

Ацикличный граф не только уменьшает количество вероятных ошибок, но и сокращает количество ненужных зависимостей позволяет пройти полный путь по графу зависимостей от начала и до конца. Т.е. мы всегда знаем и быстро определяем всю цепочку зависимостей, в которой присутствует класс/копонент/модель и т.д.

Такой граф зависимостей - Ациклически ориентированный (Directed Acyclic Graph)

Как создать/поддержать такой граф зависимостей или исправить цикл:

- Воспользоваться DIP и развернуть поток управления той зависимости, которая приводит к циклу, самое простое - закрыть за интерфейсом и делегировать реализацию в нужный компонент
- Создать новый компонент, от которого будут зависеть те компоненты, которые ранее создавали данную циклическую зависимость

### SDP - Staple Dependecies Principle Принцип устойчивых зависимостей

Устойчивость в данном ключе можно расшифровать как сложность изменения компонента. Может показаться, что устойчивым должен быть объект с минимумом зависящих от него компонентов, но на самом деле все наоборот:

Чем больше больше объектов зависит от компонента, тем больше согласованных изменений в нем нужно произвести, т.е. повышает сложность его изменения, а значит и устойчивость

Отсюда и наоборот - чем меньше от компонента звисит, тем менее он устойчив и легче поддается изменениям

I = F-in / (F-in - F-out)

I -  устойчивость от 0 до 1 (где 0 - максимальная устойчивость)

F-in - количество объектов, зависящих от компонента

F-out - количество объектов, от которых зависит компонент

Для чего все это?

Для основы принципа SDP - устойчивость компонента должна быть больше устойчивости компонентов, от которых он зависит. Метрика устойчивость должна уменьшаться в направлении зависимости. От самых неустойчивых к самым стабильным.

Например компоненты Android SDK можно считать более устойчивыми по отношению к компонентам разрабатываемого приложения. Core модуль приложения так же более устойчив (в правильной реализации архитектуры), и от него зависят менее устойчивые модули, по типу сетевой части, которая использует его базовый инструментарий

api service → network tooling → core

Где core - самый устойчивый, а api service - самый неустойчивый

Отсюда выходит ограничение - устойчивые компоненты не должны содержать зависимостей от неустойчивых, то есть в core модуль не должен зависеть от конкретных моделей api service

### SAP - Stable Abstractions Principle Принцип устойчивости абстракций

Абстрактность компонента должна быть пропорциональная его устойчивости

Устойчивый компонент, это может быть и хорошо, но как в такой ситуации сделать его достаточно гибким? Использовать абстракции, которые позволят сделать компонент более податливым к расширению функционала, что будет соответствовать принципу OCP SOLID

Наиболее поддающийся к расширению компонент будет содержать больше интерфейсов и абстрактных классов

Чаща весов:

Устойчивость против Абстрактности

**Снова дело в балансе**

- Чем более устойчивые и менее абстрактные компоненты, тем сложнее их расширить, э то самые неповоротливые части системы. Но такие компоненты тоже имеют место быть - базовые классы SDK, базы данных, низкоуровневые инструменты с минимумом зависимостей, это меняется с очень небольшой вероятностью
- С другой стороны чем менее устойчивые и более абстрактные компоненты - тем меньше пользы они приносят и меньше используются в проекте, вплоть до того, что это могут быть просто забытые и неиспользуемые интерефейсы и классы

Выход так, что где-то по середине должен быть баланс Устойчивости и абстрактности, и он идет таким образом

Чем более абстрактный компонент - тем более он должен быть устойчивый, и наоборот - менее устойчивый - значит менее абстрактный, то есть более конкретный

Снова пример из структуры

api service → network tooling → core

Здесь в api service содержатся более конкретные модели данных, конкретные реализации сетевых интерфейсов, которые менее устойчивы, по сравнению с абстракциями этих интерфейсов в network tooling

**Интересная мысль из книги:**

**Цель формы/структуры архитектуры - упростить разработку, деплой и сопровождение системы, где главная стратегия упрощения заключается в том, чтобы и дальше можно было иметь больше вариантов и гибкости**