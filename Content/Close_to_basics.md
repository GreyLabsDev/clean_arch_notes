# Ближе к основам

1) Любая из базовых парадигм программирования накладывает **ограничения** на разработку.

Структурная парадигма - ограничение на прямую передачу управления

ООП - ограничение на косвенную передачу управления

Функциональное - ограничение на присваивание

Любая из парадигм вводит правило на то, что **нельзя** делать, чтобы тем самым уменьшить количество хаоса в коде, очистить зависимости между компонентами и улучшить в общем итоговое ПО. Все как в жизни - правила и законы накладывают ограничения, дабы из хаоса создать порядок и заставить работать системы по четким понятным правилам, которые поддаются анализу и помогают создавать, понимать и поддерживать данные системы

2) Интересный факт про доказуемость правильности работы программы и тестирование. Разработка ПО сродни науки, т.к. в ней нельзя доказать истинность правильной работы ПО полностью невозможно, а возможно лишь доказать правильность работы ПО только через неудачи в попытках доказать ложную работу ПО.

Отсюда факт - тестирование не доказывает полностью истинность правильной работы ПО, оно лишь доказывает наличие в нем ошибок, и через итерации неудачных доказательств наличия ошибок, позволяет сказать, что ПО действует **достаточно** правильно в текущих условиях и требованиях к нему. 

**В разработке ПО работает правильно опровергающих доказательств**

3) Современная инкапсуляция несовершенна. Т.к. в современных языках программирования, поля и функции класса нераздельны с их реализациях, а в том же классическом С к реализации не было доступа, т.к. описание класса было в заголовочном файле, а реализация в теле, доступ к которому из вне был закрыт. Но данное несовершенство закрывается за стандартными и уже привычными для всех модификаторами доступа по типу **public/private/protected,** они ограничивают области доступа к полям/функциям на уровне исполнения, но мы все равно можем этот код изучить в редакторе. Современная инкапсуляция в части языков полагается на совесть разработчика и изначально исходит из того, что они не будут обходить эти ограничения (как например через рефлексию в Java)

4) Современное наследование стало более явным и читаемым, т.к. раньше в том же С оно основывалось не на прямом наследовании и привязке экземпляра класса потомка к родительскому, а на сходстве сигнатур классов по наличию аналогичных полей класса потомка и родительского

5) Инверсия зависимостей по Роберту Мартину - направление зависимостей в компонентах противоположно направлению потоку управления между этими компонентами

При прямой зависимости - компоненты зависят от других, более низкоуровневых напрямую и управляют ими так же напрямую, завязываясь на конкретную реализацию

**В ООП есть интерфейсы, которые позволяют взять на себя зависимость и управление будет обращено к конкретной реализации интерфейса**

Простой пример прямой зависимости

UI → DOMAIN → DATA

Но можно развернуть зависимость так, что UI и DATA слои, будут реализовывать интерфейсы взаимодействия с уровнем DOMAIN (бизнес-логика) и тогда направление зависимостей будет следующим

UI → DOMAIN ← DATA

В таком случае все три слоя полностью независимы и отделимы друг от друга, каждый слой выполняет только свои задачи, UI и DATA могут под капотом быть любыми и просто подключаться к DOMAIN через описанный в нем интерфейс. Вот тебе и базовая чистая архитектура в ООП, как она есть