# Границы компонентов и DIP

DOMAIN (DB Interface) ← DATA (DB, DB Interface **Implementation**)

Границы компонентов заканчиваются в зоне их ответственности на разных уровнях приложения. В данном случае граница слоя данных заканчивается перед интерфейсом слоя бизнес логики, который описывает протокол взаимодействия с уровнем данных

Сразу вижно, что зависимости здесь инвертированы при помощи интерфейса, который реализован уже на уровне DATA

Пример из железа:

ОС содержит интерфейсы для общения с периферией и встроенными устройствами, на стороне любого ПО реализуются эти интерфейсы и здесь тоже четка видна граница, что ОС не зависит от нашего приложения, а приложение зависит от ОС и обращается к железу с помощью интерфейсов

В целом можно рассмотреть архитектуру приложения как базовые бизнес правила и подключаемые к ним компоненты, и граница будет как раз между нашим уровнем DOMAIN и всеми остальными, которые от него зависят - данные, интерфейс, модули вывода/отправки отчетов или формирования графиков, сервисы и т.п.

От кода к более абстрактным вещам:

- Простейшее разделение границ может быть посредством модификаторов доступа в коде, но у нас может быть одна большая простыня на тысячи строк
- Дальше разраничить можно по отдельным файлам и пакетам (директориям), уже лучше, четче видны логические уровни
- Затем можно разбить проект на модули, что является более высокоуровневым разграничением и отделит более крупные функциональные блоки, позволяя облегчить их независимую разработку и поддержку. Здесь уже даже можно говорить об удобстве развертывания (сборки), т.к. такое разделение позволит собирать не все приложение сразу каждый раз, а только те модули, в которых были изменения (Например более стабильным будет core модуль и его придется собирать реже)

Постепенное очерчивание границ в проекте начиная с обычных файлов, заканчивая модулями, позволяет распределить ответственность на всех уровнях приложения, от низкоуровневых функций и классов, до высокоуровневых модулей, отвечающих за конкретную часть функционала. 

Грубый пример:

Начальный этап - все в одном модуле и 1ом пакете, бизнес логика, UI, фичи, авторизация, данные

Конечный - отдельный модуль базовой бизнес логики, модуль авторизации, UiKit модуль со всеми компонентами интерфейса и т.д.

Границы так же могут быть очерчены по каким-либо компонентам системы - например граница между кодом логики, выполняющейся в самом приложении здесь и сейчас и сервисом, который приложение запускает, отдавая туда часть задачи.